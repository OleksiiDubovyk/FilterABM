#' Helper, draw random points from a kernel density estimation
#'
#' @param kde A kernel density estimation as generated by density()
#' @param n Number of values to draw
#'
#' @returns Random values drawn from an empirical distribution
#' @export
#'
rkde <- function(kde, n = 1) {
  sample(x = kde$x, size = n, replace = TRUE, prob = kde$y) + rnorm(n = n, sd = kde$bw)
}

#' Helper, Kolmogorov-Smirnov statistic for two empirical species abundance distributions
#'
#' @param sad1 Vector, abundances of species in one community
#' @param sad2 Vector, abundances of species in the second community
#'
#' @returns Kolmogorov-Smirnov statistic
#' @export
#'
sad_ks <- function(sad1, sad2){
  len <- max(length(sad1), length(sad2))
  x1 <- sort(sad1/sum(sad1))
  x2 <- sort(sad2/sum(sad2))
  c1 <- cumsum(x1)
  c2 <- cumsum(x2)
  if (length(sad1) > length(sad2)){
    c2 <- c(c2, rep(1, (length(sad1) - length(sad2))))
  } else if (length(sad1) < length(sad2)) {
    c1 <- c(c1, rep(1, (length(sad2) - length(sad1))))
  }
  return(max(abs(c1 - c2)))
}

#' Helper, permutational expectation of Kolmogorov-Smirnov statistic for an observed SAD and SAD from random sample of regional pool
#'
#' @param sad Vector, abundances of species in the observed community
#' @param mc A regional pool object of class "FilterABM_mc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_mc}).
#' @param nperm Numeric, number of permutations.
#'
#' @returns Kolmogorov-Smirnov statistic for each permutation
#' @export
#'
sad_ks_boot <- function(sad, mc, nperm = 100){
  ks_boot <- numeric(nperm)
  n <- sum(sad)
  for (i in 1:nperm){
    sad_exp <- mc[sample(1:nrow(mc), size = n, replace = T, prob = mc$abundance), ] %>%
      group_by(species) %>%
      summarise(n = n()) %>%
      .$n %>% sort(decreasing = T)
    ks_boot[i] <- sad_ks(sad1 = sad, sad2 = sad_exp)
  }
  return(ks_boot)
}

#' Helper, Kolmogorov-Smirnov statistic for two empirical KDE distributions
#'
#' @param tad1 Kernel density estimated pdf of trait values in a community
#' @param tad2 Kernel density estimated pdf (note: from and to arguments in stat::density() should be the same as for tad1)
#'
#' @returns Kolmogorov-Smirnov statistic
#' @export
#'
tad_ks <- function(tad1, tad2){
  c1 <- cumsum(tad1$y)
  c1 <- c1 / max(c1)
  c2 <- cumsum(tad2$y)
  c2 <- c2 / max(c2)
  return(max(abs(c1 - c2)))
}

#' Helper, permutational expectation of Kolmogorov-Smirnov statistic for an observed TAD and TAD from random sample of regional pool
#'
#' @param tad Kernel density estimated pdf (output of stats::density() function)
#' @param mc A regional pool object of class "FilterABM_mc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_mc}).
#' @param nperm Numeric, number of permutations.
#'
#' @returns Kolmogorov-Smirnov statistic for each permutation
#'
#' @importFrom stats density
#' @export
#'
tad_ks_boot <- function(tad, mc, nperm = 100){
  ks_boot <- numeric(nperm)
  n <- tad$n
  for (i in 1:nperm){
    tad_exp <- draw_lcom(mc = mc, lh = FilterABM::init_envt(), nind = n) %>%
      .$trait %>%
      density(
        from = min(tad$x),
        to = max(tad$x)
      )
    ks_boot[i] <- tad_ks(tad1 = tad, tad2 = tad_exp)
  }
  return(ks_boot)
}

#' Helper, Jaccard index
#'
#' @param spp1 Species identities in community 1
#' @param spp2 Species identities in community 2
#'
#' @returns Jaccard index
#' @export
#'
jaccard <- function(spp1, spp2){
  spp <- unique(c(spp1, spp2))
  # length(spp[(spp %in% spp1) & (spp %in% spp2)]) / length(spp)
  sum((spp %in% spp1) * (spp %in% spp2)) / length(spp)
}

#' Helper, permutational expectation of Jaccard index for observed community and random draws from regional pool
#'
#' @param obs Observed community
#' @param mc A regional pool object of class "FilterABM_mc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_mc}).
#' @param nperm Numeric, number of permutations.
#'
#' @returns Jaccard indices
#' @export
jaccard_boot <- function(obs, mc, nperm = 100){
  j_boot <- numeric(nperm)
  n <- nrow(obs)
  for (i in 1:nperm){
    s1 <- unique(obs$species)
    s2 <- draw_lcom(mc = mc, lh = FilterABM::init_envt(), nind = n) %>%
      .$species %>% unique()
    j_boot[i] <- jaccard(s1, s2)
  }
  return(j_boot)
}

#' Helper, Bray-Curtis similarity
#'
#' @param com1 Tibble for community 1 with two columns: species and n
#' @param com2 Tibble for community 2 with two columns: species and n
#'
#' @returns Bray-Curtis index
#' @export
braycurtis <- function(com1, com2){
  com <- left_join(com1, com2, by = "species") %>%
    mutate(n.x = ifelse(is.na(n.x), 0, n.x),
           n.y = ifelse(is.na(n.y), 0, n.y))
  tmp <- com %>%
    mutate(minn = 2*map2_dbl(n.x, n.y, min),
           sumn = n.x + n.y) %>%
    select(minn, sumn) %>%
    apply(2, sum)
  tmp[1]/tmp[2]
}

#' Helper, permutational expectation of Bray-Curtis index for observed community and random draws from regional pool
#'
#' @param obs Observed community
#' @param mc A regional pool object of class "FilterABM_mc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_mc}).
#' @param nperm Numeric, number of permutations.
#'
#' @returns Bray-Curtis indices
#' @export
braycurtis_boot <- function(obs, mc, nperm = 100){
  bc_boot <- numeric(nperm)
  n <- nrow(obs)
  for (i in 1:nperm){
    s1 <- obs %>% group_by(species) %>% summarise(n = n())
    s2 <- draw_lcom(mc = mc, lh = FilterABM::init_envt(), nind = n) %>%
      group_by(species) %>% summarise(n = n())
    bc_boot[i] <- braycurtis(s1, s2)
  }
  return(bc_boot)
}

#' Helper, 95-percentile range of a values
#'
#' @param x A numeric vector.
#'
#' @returns Range between the 2.5th and 9.75th percentile
#' @export
fd95 <- function(x){
  unname(quantile(x, 0.975) - quantile(x, 0.025))
}

#' Run a simulation of environmental filtering on specified metacommunity, local habitat, and local community objects
#'
#' @description
#' Requires an input of pre-defined metacommunity, local habitat, and local community objects, the two latter of which are iteratively modified to reflect changes caused by environmental filtering.
#' This function is not fully enclosed, but expects pre-initialized input objects for regional pool, local habitat, and community.
#' This allows running multiple simulations on identical input.
#'
#' The output is memory-moderate: intermediate results of simulation steps are discarded.
#' Use \code{run_sim()} to preserve all intermediate steps.
#'
#' @param mc A regional pool object of class "FilterABM_mc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_mc}).
#' @param lh A local habitat object of class "FilterABM_lh"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_lh}).
#' @param lc A local community object of class "FilterABM_lc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_lc}).
#'
#' @param nsteps Positive integer, number of simulation time steps.
#'
#' @param progress_bar Logical, whether to show the progress bar for the simulation run; default to FALSE.
#'
#' @param recruitment Non-negative double, recruitment rate (i.e., expectation of number of individuals recruited into local habitat per patch per time step). Feeds into \code{recruit()}.
#'
#' @param dispersal Non-negative numeric, dispersal rate per habitat patch, i.e., expectation of the number of individuals per patch that disperse to a neighboring patch. Feeds into \code{dispersal()}.
#'
#' @param reproduction Non-negative numeric; mass at which individuals reproduce. Feeds into \code{dem()}.
#' @param expenditure Numeric; amount of body mass each individual needs to spend in order to survive one time step. Feeds into \code{dem()}.
#'
#' @param res_input Numeric, increment of the resource level within a time step. Feeds into \code{lh_input_res()}.
#'
#' @param intake Positive numeric, single-meal resource intake by an individual in an event of a successful feeding. Feeds into \code{forage()}.
#'
#' @param clustering Numeric, effect of niche clustering on probability of competition (between 0 and 1). Default to one.
#' If zero, local environmental conditions do not affect individual resource intake. Feeds into \code{forage()}.
#' @param dispersion Numeric, effect of niche dispersion on probability of trait filtering by the environment (between 0 and 1). Default to one.
#' If zero, trait differences among individuals do not affect resource intake. Feeds into \code{forage()}.
#'
#' @returns A diagnostic named list with the following elements:
#' [["mc"]] - input regional pool;
#' [["lh"]] - input local habitat;
#' [["params"]] - named vector, other simulation parameters;
#' [["runtime"]] - time the simulation took, in minutes;
#' [["extinct"]] - logical, whether the local community went extinct; if TRUE, the rest of the elements of the list are empty, otherwise, all metrics below are evaluated for the local community at the last time step;
#' [["S"]] - number of species;
#' [["nind"]] - number of individuals;
#' [["sad"]] - species abundance distribution (SAD);
#' [["sad_ks"]] - median (100 permutations) Kolomogorov-Smirnov statistic for the observed SAD and a community of the same size randomly drawn from the regional pool;
#' [["sad_j]] - median (100 permutations) Jaccard index for the observed SAD and a community of the same size randomly drawn from the regional pool;
#' [["sad_bc]] - - median (100 permutations) Bray-Curtis index for the observed SAD and a community of the same size randomly drawn from the regional pool;
#' [["tad"]] - trait abundance distribution (TAD) as an output of kernel density estimation (stats::density());
#' [["t_mean"]] - mean trait value;
#' [["t_mean0"]] - mean trait value in a community of the same size randomly drawn from the regional pool;
#' [["t_var"]] - trat variance;
#' [["t_var0"]] - trat variance in a community of the same size randomly drawn from the regional pool;
#' [["tad_ks"]] - median (100 permutations) Kolomogorov-Smirnov statistic for the observed TAD and a community of the same size randomly drawn from the regional pool;
#' [["FD"]] - range between the 0.025th and 0.975th percentile of observed trait values;
#' [["FD0"]] - range between the 0.025th and 0.975th percentile of trait values of random subsample from the metacommunity;
#' [["FDall"]] - range between the 0.025th and 0.975th percentile of observed trait values within the regional pool;
#'
#' @import progress
#' @importFrom stats approx
#'
#' @export
#'
run_sim_ <- function(mc, lh, lc,
                     nsteps = 500,
                     progress_bar = FALSE,
                     recruitment = 0.05,
                     dispersal = 0.05,
                     reproduction = 0.1, expenditure = 0.1,
                     res_input = 10,
                     intake = 1,
                     clustering = 1, dispersion = 1){

  # formal checks
  if ((nsteps %% 1) != 0){
    stop("`nsteps` in `run_FilterABM` must be integer.")
  }

  if (nsteps < 1){
    stop("`nsteps` in `run_FilterABM` must be positive.")
  }

  # double check if lc is missing - not a big deal if it does
  if (missing(lc)){
    warning("`lc` argument missing in `run_sim()`, substituted with default.")
    lc <- draw_lcom(mc = mc, lh = lh, nind = 1)
  }

  # start time
  t1 <- Sys.time()

  # progress bar if asked for
  if (progress_bar){
    pb <- progress::progress_bar$new(
      format = "Simulation running [:bar] :percent step :current - elapsed :elapsed  ETA: :eta",
      total = nsteps, clear = FALSE, width = 100)
  }

  for (step in 1:nsteps){

    # update progress bar
    if (progress_bar) pb$tick()

    # stop if community goes extinct
    if (nrow(lc) == 0) break

    # == SIMULATION BODY ==

    # recruitment
    lc <- recruit(lc = lc, mc = mc, lh = lh, recruitment = recruitment)
    # demography
    lc <- dem(lc = lc, mc = mc, reproduction = reproduction, expenditure = expenditure)
    if (nrow(lc) == 0) break
    # dispersal
    lc <- disperse(lc = lc, lh = lh, dispersal = dispersal)
    # resource input
    lh <- lh_input_res(lh = lh, res_input = res_input)
    # foraging
    res_prior <- sum(lh$res) # save resource level prior to processes
    frg_out <- forage(lc = lc, lh = lh, intake = intake, clustering = clustering, dispersion = dispersion) # forage
    lc <- frg_out[["lc"]] # extract local community
    if (nrow(lc) == 0) break
    lh <- frg_out[["lh"]]

    # == END ==
    t2 <- Sys.time()

  }

  out <- list(
    "mc" = mc,
    "lh" = lh,
    "params" = c(
      "nsteps" = nsteps,
      "recruitment" = recruitment,
      "dispersal" = dispersal,
      "reproduction" = reproduction,
      "expenditure" = expenditure,
      "res_input" = res_input,
      "intake" = intake,
      "clustering" = clustering,
      "dispersion" = dispersion
    ),
    "runtime" = as.numeric(difftime(t2, t1, units = "m")),
    "extinct" = nrow(lc) == 0,
    "S" = NA,
    "nind" = NA,
    "sad" = NA,
    "sad_ks" = NA,
    "sad_j" = NA,
    "sad_bc" = NA,
    "tad" = NA,
    "t_mean" = NA,
    "t_mean0" = NA,
    "t_var" = NA,
    "t_var0" = NA,
    "tad_ks" = NA,
    "tad_overlap" = NA,
    "FD" = NA,
    "FD0" = NA,
    "FDall" = NA
  )

  if (!out$extinct){

    if (nrow(lc) > 1){

      out$S <- lc$species %>% unique() %>% length()

      out$nind <- nrow(lc)

      out$sad <- lc %>%
        group_by(species) %>%
        summarise(n = n()) %>%
        .$n %>% sort(decreasing = T)

      out$sad_ks <- median(sad_ks_boot(out$sad, out$mc))

      out$sad_j <- FilterABM::jaccard_boot(obs = lc, mc = mc) %>% median()

      out$sad_bc <- FilterABM::braycurtis_boot(obs = lc, mc = mc) %>% median()

      out$tad <- density(
        lc$trait,
        # KDE for plus/minus 3 sigmas from the most extreme trait values
        from = min(min(mc$trait), min(lc$trait)) - 3*(max(mc$trait_sd)^0.5),
        to = max(max(mc$trait), max(lc$trait)) + 3*(max(mc$trait_sd)^0.5)
      )

      out$t_mean <- mean(lc$trait)
      out$t_var <- var(lc$trait)

      lc_tmp <- lapply(1:100, function(j) FilterABM::draw_lcom(mc = mc, lh = lh, nind = nrow(lc)))
      out$t_mean0 <- lapply(lc_tmp, function(l) mean(l$trait)) %>% unlist() %>% mean()
      out$t_var0 <- lapply(lc_tmp, function(l) var(l$trait)) %>% unlist() %>% mean()

      out$tad_ks <- median(tad_ks_boot(out$tad, out$mc))

      out$FD <- FilterABM::fd95(lc$trait)

      out$FD0 <- lapply(lc_tmp, function(l) FilterABM::fd95(l$trait)) %>% unlist() %>% mean()

      out$FDall <- FilterABM::fd95(mc$trait)

    }else{

      out$S <- 1

      out$nind <- 1

      out$sad <- 1

      out$sad_ks <- NA

      out$sad_j = NA

      out$sad_bc = NA

      out$tad <- lc$trait[1]

      out$t_mean <- lc$trait[1]
      out$t_var <- 0

      lc_tmp <- draw_lcom(mc = mc, lh = lh, nind = nrow(lc))
      out$t_mean0 <- lc_tmp$trait[1]
      out$t_var0 <- 0

      out$tad_ks <- NA

    }
  }

  return(out)

}

#' Contained simulation run
#'
#' @param nsteps Positive integer, number of simulation time steps.
#' @param progress_bar Logical, whether to show the progress bar for the simulation run; default to FALSE.
#'
#' @param M Integer, species richness within metacommunity, positive integer.
#' @param env_mean_mc Numeric, mean environmental factor value within the extent of a metacommunity.
#' @param env_sd_mc Non-negative numeric, variation of environmental factor value within the extent of a metacommunity.
#' @param cauchy Non-negative numeric, delta parameter in Cauchy function used to connect species' trait values and log-abundances.
#' @param trait_sds Non-negative numeric, intraspecific trait variation; either a single value if same for all species, or a M-length vector.
#' @param max_abun Numeric, the maximum abundance allowed for the most abundant species in the metacommunity.
#'
#' @param npatch Positive integer, number of patches in the environment.
#' @param res Non-negative numeric, available resource level within each patch of the local habitat.
#' @param gradient Character, the rule by which patches get their values of env, either:
#' \code{gradient = "random"} - default value, env is an independent random variable drawn from N(env_mean, env_sd),
#' \code{gradient = "linear"} - env changes linearly from patch number 1 to patch number \code{npatch} with min and max drawn from 95% bound of N(env_mean, env_sd),
#' \code{gradient = "correlated"} - environmental factor is correlated with patch number with correlation coefficient equal \code{rho}, or
#' \code{gradient = "clustered"} - for K clusters, there are linearly distributed local env_means and small env_sd.
#' @param K Positive integer, number of clusters if \code{gradient = "clustered"}.
#' @param env_mean_lh Numeric, mean value. of the environmental factor across all habitat patches.
#' @param env_sd_lh Positive numeric, variation of the environmental factor across all habitat patches.
#' @param rho Positive numeric between \code{0} and \code{1}, correlation coefficient between patch number and environmental factor when \code{gradient = "correlated"}.
#'
#' @param nind0 Positive integer, community size at simulation initialization.
#'
#' @param recruitment Non-negative double, recruitment rate (i.e., expectation of number of individuals recruited into local habitat per patch per time step). Feeds into \code{recruit()}.
#' @param dispersal Non-negative numeric, dispersal rate per habitat patch, i.e., expectation of the number of individuals per patch that disperse to a neighboring patch. Feeds into \code{dispersal()}.
#' @param reproduction Non-negative numeric; mass at which individuals reproduce. Feeds into \code{dem()}.
#' @param expenditure Numeric; amount of body mass each individual needs to spend in order to survive one time step. Feeds into \code{dem()}.
#' @param res_input Numeric, increment of the resource level within a time step. Feeds into \code{lh_input_res()}.
#' @param intake Positive numeric, single-meal resource intake by an individual in an event of a successful feeding. Feeds into \code{forage()}.
#' @param clustering Numeric, effect of niche clustering on probability of competition (between 0 and 1). Default to one.
#' If zero, local environmental conditions do not affect individual resource intake. Feeds into \code{forage()}.
#' @param dispersion Numeric, effect of niche dispersion on probability of trait filtering by the environment (between 0 and 1). Default to one.
#' If zero, trait differences among individuals do not affect resource intake. Feeds into \code{forage()}.
#'
#' @returns Simulation output from \code{run_sim_()}.
#' @export
crun_sim_ <- function(nsteps = 500,
                      progress_bar = FALSE,
                      M = 120, env_mean_mc = 0, env_sd_mc = 1, cauchy = 1, trait_sds = 0, max_abun = 1e6,
                      npatch = 10, res = 1000, gradient = "random", K = 3, env_mean_lh = 0, env_sd_lh = 25, rho = 0.75,
                      nind0 = 1000,
                      recruitment = 0.05,
                      dispersal = 0.05,
                      reproduction = 0.1, expenditure = 0.1,
                      res_input = 10,
                      intake = 1,
                      clustering = 1, dispersion = 1){

  mc1 <- init_meta(M = M,
                   env_mean_mc = env_mean_mc,
                   env_sd_mc = env_sd_mc,
                   cauchy = cauchy,
                   trait_sds = trait_sds,
                   max_abun = max_abun)
  lh1 <- init_envt(npatch = npatch,
                   res = npatch,
                   gradient = gradient,
                   K = K,
                   env_mean_lh = env_mean_lh,
                   env_sd_lh = env_sd_lh,
                   rho = rho)
  lc1 <- draw_lcom(mc = mc1,
                   lh = lh1,
                   nind = nind0,
                   new_mass = expenditure*1.1)
  run_sim_(mc = mc1,
           lh = lh1,
           lc = lc1,
           nsteps = nsteps,
           progress_bar = progress_bar,
           recruitment = recruitment,
           dispersal = dispersal,
           reproduction = reproduction,
           expenditure = expenditure,
           res_input = res_input,
           intake = intake,
           clustering = clustering,
           dispersion = dispersion)
}

#' [Long output] Run a simulation of environmental filtering on specified metacommunity, local habitat, and local community objects
#'
#' @description
#' Requires an input of pre-defined metacommunity, local habitat, and local community objects, the two latter of which are iteratively modified to reflect changes caused by environmental filtering.
#' This function is not fully enclosed, but expects pre-initialized objects.
#' This allows running multiple simulations on identical input.
#'
#' Unlike \code{run_sim_()}, it saves the data from each time step, which does provide more insight on trait distribution across individuals with time, but is more memory-intensive.
#'
#'
#' @param mc A metacommunity object of class "FilterABM_mc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_mc}).
#' @param lh A local habitat object of class "FilterABM_lh"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_lh}).
#' @param lc A local community object of class "FilterABM_lc"/"tbl_df"/"tbl"/"data.frame" (see \code{?FilterABM::FilterABM_lc}).
#'
#' @param nsteps Positive integer, number of simulation time steps.
#'
#' @param progress_bar Logical, whether to show the progress bar for the simulation run; default to FALSE.
#'
#' @param recruitment Non-negative double, recruitment rate (i.e., expectation of number of individuals recruited into local habitat per patch per time step). Feeds into \code{recruit()}.
#'
#' @param dispersal Non-negative numeric, dispersal rate per habitat patch, i.e., expectation of the number of individuals per patch that disperse to a neighboring patch. Feeds into \code{dispersal()}.
#'
#' @param reproduction Non-negative numeric; mass at which individuals reproduce. Feeds into \code{dem()}.
#' @param expenditure Numeric; amount of body mass each individual needs to spend in order to survive one time step. Feeds into \code{dem()}.
#'
#' @param res_input Numeric, increment of the resource level within a time step. Feeds into \code{lh_input_res()}.
#'
#' @param intake Positive numeric, single-meal resource intake by an individual in an event of a successful feeding. Feeds into \code{forage()}.
#'
#' @param clustering Numeric, effect of niche clustering on probability of competition (between 0 and 1). Default to one.
#' If zero, local environmental conditions do not affect individual resource intake. Feeds into \code{forage()}.
#' @param dispersion Numeric, effect of niche dispersion on probability of trait filtering by the environment (between 0 and 1). Default to one.
#' If zero, trait differences among individuals do not affect resource intake. Feeds into \code{forage()}.
#'
#' @returns A list with a quasi-"FilterABM_lc" local community object that has an additional column for time step ([["lcs"]]).
#' Additionally, habitat history at each time step ([["habitat"]]), and the total resource consumed per time step ([["consumed_resource"]]).
#' Input arguments included in the output as well.
#'
#' @import progress
#'
#' @export
#'
run_sim <- function(mc, lh, lc,
                     nsteps = 500,
                     progress_bar = FALSE,
                     recruitment = 0.05,
                     dispersal = 0.05,
                     reproduction = 0.1, expenditure = 0.1,
                     res_input = 10,
                     intake = 1,
                     clustering = 1, dispersion = 1){

  # formal checks
  if ((nsteps %% 1) != 0){
    stop("`nsteps` in `run_FilterABM` must be integer.")
  }

  if (nsteps < 1){
    stop("`nsteps` in `run_FilterABM` must be positive.")
  }

  # double check if lc is missing - not a big deal if it does
  if (missing(lc)){
    warning("`lc` argument missing in `run_sim()`, substituted with default.")
    lc <- draw_lcom(mc = mc, lh = lh, nind = 1)
  }

  # initialize additional output
  lc_out <- lc %>%
    mutate(timestep = 0)
  hab_patches <- lh$patch
  out_lh <- matrix(data = NA, nrow = nsteps + 1, ncol = length(hab_patches))
  out_res_consumed <- numeric(nsteps)

  # progress bar if asked for
  if (progress_bar){
    pb <- progress::progress_bar$new(
      format = "Simulation running [:bar] :percent step :current - elapsed :elapsed  ETA: :eta",
      total = nsteps, clear = FALSE, width = 100)
  }

  for (step in 1:nsteps){

    # update progress bar
    if (progress_bar) pb$tick()

    # stop if community goes extinct
    if (nrow(lc) == 0) break

    # == SIMULATION BODY ==

    # recruitment
    lc <- recruit(lc = lc, mc = mc, lh = lh, recruitment = recruitment)
    # demography
    lc <- dem(lc = lc, mc = mc, reproduction = reproduction, expenditure = expenditure)
    if (nrow(lc) == 0) break
    # dispersal
    lc <- disperse(lc = lc, lh = lh, dispersal = dispersal)
    # resource input
    lh <- lh_input_res(lh = lh, res_input = res_input)
    # foraging
    res_prior <- sum(lh$res) # save resource level prior to processes
    frg_out <- forage(lc = lc, lh = lh, intake = intake, clustering = clustering, dispersion = dispersion) # forage
    lc <- frg_out[["lc"]] # extract local community
    if (nrow(lc) == 0) break
    lh <- frg_out[["lh"]]

    # == END ==

    # write output

    lc_out <- lc_out %>%
      add_row(lc %>% mutate(timestep = step))
    out_lh[step + 1, ] <- lh$res[sapply(hab_patches, function(j) which(lh$patch == j))]
    out_res_consumed[step] <- res_prior - sum(lh$res)

  }

  rs <- list("lcs" = lc_out,
             "habitat" = out_lh,
             "consumed_resource" = out_res_consumed,
             "coord" = list(
               "lh" = hab_patches
             ),
             "mc" = mc,
             "lh" = lh,
             "params" = c(
               "nsteps" = nsteps,
               "recruitment" = recruitment,
               "dispersal" = dispersal,
               "reproduction" = reproduction,
               "expenditure" = expenditure,
               "res_input" = res_input,
               "intake" = intake,
               "clustering" = clustering,
               "dispersion" = dispersion
             )
  )

  rs <- structure(rs, class = c("FilterABM_runsim", class(rs)))

  return(rs)

}

#' Diagnostic plots for a simulation output (for long output)
#'
#' @param x An output of \code{run_sim_()}.
#' @param y Parameter two.
#' @param ... Arguments passed to or from other methods.
#'
#' @import ggplot2
#' @importFrom gridExtra grid.arrange
#'
#' @exportS3Method base::plot
#'
plot.FilterABM_runsim <- function(x, y, ...){

  runsim <- x

  p1 <- ggplot2::ggplot() +
    ggplot2::geom_bin_2d(aes(x = timestep, y = trait), data = runsim$lcs) +
    ggplot2::scale_fill_gradientn(colours = terrain.colors(10)) +
    ggplot2::geom_line(aes(x = timestep, y = trait), data = runsim$lcs %>% group_by(timestep) %>% summarise(trait = mean(trait))) +
    ggplot2::xlab("Time step") + ggplot2::ylab("Trait") + ggplot2::theme(legend.position="none") +
    ggplot2::geom_hline(yintercept = mean(runsim$mc$trait), linetype = "dashed", col = "red") +
    ggplot2::geom_hline(yintercept = mean(runsim$lh$env), linetype = "dotted", col = "blue")

  p2 <- runsim$lcs %>%
    group_by(timestep, patch) %>% summarise(n = n()) %>%
    group_by(timestep) %>% summarise(n = mean(n)) %>%
    ggplot(aes(x = timestep, y = n)) + geom_line() + ylab("Ind. / patch") + xlab("Time step")

  p3 <- runsim$lcs %>% group_by(timestep) %>% summarise(w = mean(mass)) %>%
    ggplot(aes(x = timestep, y = w)) + geom_line() + ylab("Mean mass") + xlab("Time step")

  p4 <- tibble(timestep = 1:(nrow(runsim$habitat)-1),
               res = runsim$habitat[-1,] %>% apply(1, mean)) %>%
    ggplot(aes(x = timestep, y = res)) +
    geom_line() +
    ylim(0, NA) +
    xlab("Time step") + ylab("Available res / patch")

  p5 <-tibble(timestep = 1:length(runsim$consumed_resource),
              cres = runsim$consumed_resource/length(runsim$coord$lh)) %>%
    ggplot(aes(x = timestep, y = cres)) +
    geom_line() +
    ylim(0, NA) +
    xlab("Time step") + ylab("Consumed res / patch")

  finish <- runsim$lcs %>%
    filter(timestep == max(timestep)) %>%
    select(-timestep)

  p6 <- ggplot() +
    geom_density(data = finish,
                 mapping = aes(x = trait, ggplot2::after_stat(count), fill = factor(species)),
                 position = "stack", show.legend = F, na.rm = F) +
    theme_minimal() +
    geom_density(data = draw_lcom(
      mc = runsim$mc,
      lh = runsim$lh,
      nind = nrow(finish)),
                 mapping = aes(x = trait, ggplot2::after_stat(count)),
                 show.legend = F, linetype = "dotted") +
    xlab("Trait value") + ggplot2::ylab("Individuals")

  finish_sad <- finish %>%
    group_by(species) %>%
    summarize(n = n())

  p7 <- ggplot() +
    geom_point(data = draw_lcom(
      mc = runsim$mc,
      lh = runsim$lh,
      nind = nrow(finish)) %>%
        group_by(species) %>%
        summarize(abundance = n()) %>%
        arrange(desc(abundance)) %>%
        rowid_to_column(var = "rank"),
      aes(x = rank, y = abundance), color = "gray") +
    geom_line(data = tibble(
      rank = 1:nrow(finish_sad),
      abundance = sort(finish_sad$n, decreasing = TRUE)
    ), aes(x = rank, y = abundance), lwd = 2) +
    scale_y_log10() +
    theme_minimal() +
    xlab("Rank") +
    ylab("log-Abundance")

  gridExtra::grid.arrange(p1, p2, p3, p4, p5, p6, p7,
                          layout_matrix = matrix(
                            c(1, 1, 2, 3,
                              1, 1, 4, 5,
                              6, 6, 7, 7,
                              6, 6, 7, 7), nrow = 4, byrow = T
                          )
  )

}
